meta:
  name: ravine
  engine: 4.2.1
  inspired_by: ezxzeng/sweep_squared_rot
  author: zakwaykway
units:
  kx: u # spacing
  ky: kx
  kcx: 18 # size of a keycap
  kcy: kcx

  $default_width: 18 # can't be kcx, as ergogen throws an error?? 
  $default_height: 18
  $default_autobind: 0

  # ==================== parameterisation ====================
  pinky_splay: 5
  pinky_stagger: 0.5ky # pinky to ring
  ring_splay: 3
  ring_stagger: 0.25ky # ring to middle
  index_stagger: -0.4ky # middle to index
  inner_stagger: -0.35ky # index to inner
  thumb_r: 20   # thumb splay, relative to main cluster rotation
  thumb_x: -1.5
  thumb_y: 3
  corner_r: 10  # corner splay
  corner_x: 0.5
  corner_y: 0

  center_x: 5   # shift the board's outline
  center_y: 8.5
  center_r: -16 - pinky_splay/3 - ring_splay/3 # objective rotation of middle col

  gap: 0.21 # gaps from edges, based on jlc capabilities, plus 0.01 for kicad rounding
  gap2: 0.5 # aesthetic gaps
  # ==================== object sizes ====================
  square: 102 # board's outline values
  xiao_x: 17.8 # nrf52840; 
  xiao_y: 21 # should remain constant between chips
  trrs_x: 6 # pj320a
  trrs_y: 12
  reset_x: 8 # alps skqg
  reset_y: 5.3
  slider_x: 8 # skmc02
  slider_y: 3.01
  slider_x2: 9.5 # MSS22D18 SMT
  slider_y2: 7.75
  jst_x: 6.9
  jst_y: 12.35 # including male
  coin_x: 25.9 # bs-cr2032-8 
  coin_y: 15.7
  # ==================== helper vars ====================
    # these are coordinates for the edges of keys' hotswap sockets.
    # left/right side achieved with a minus symbol (these are used in outlines, only a couple times)
  m_x: 8.635+gap # rightmost x of mx socket
  m_xy: 6.33+gap # topmost y of above x value for mx socket
  m_y: 6.73+gap # topmost y of mx socket
  c_x: 9.57+gap # rightmost x of choc socket
  c_xy: 5.05+gap # bottommost y of above x value for choc socket
  c_y: 7.6+gap # bottommost y of choc socket

points.zones:
  zero.rows: # helper [0, 0, 0] zone, to anchor the helper footprint outline
  matrix: # mx sockets face north (south-facing switch)
    anchor: 
      shift: [150, -150] # moves keyboard into kicad sheet
      rotate: center_r+pinky_splay+ring_splay # Center_r is only for middle col; it is already rotated by pinky+ring,
        # we make that subtraction here so the parameterization works out
    key:
      spread: kx
      padding: ky
      tags: switches # this will help place footprints correctly in pcbs and outlines
    rows:
      bottom.row_net: P6
      home.row_net: P7
      top.row_net: P8
    columns.pinky: 
      key.col_net: P0
      rows.home.adjust.rotate: 180 # this is to save space
      rows.bottom.skip: true  # deletes the bottom key. 23332 cluster :)
    columns.ring:
      key.col_net: P1
      rows.bottom.col_net: P0
      key.stagger: pinky_stagger
      key.origin: [-kx/2, -ky/2+ky-pinky_stagger] # set rotation origin as tangent pinky_home's corner
      key.splay: -pinky_splay
    columns.middle:
      key.col_net: P2
      rows.bottom.col_net: P1
      key.stagger: ring_stagger
      key.origin: [-kx/2, -ky/2-ring_stagger] # -ring_stagger WOULD NOT be necessary if we didn't have the encoder below
      key.splay: -ring_splay
    columns.index:
      key.col_net: P3
      key.stagger: index_stagger
      rows.bottom.col_net: P2
    columns.inner:
      key.col_net: P3
      key.row_net: P6
      rows.home.row_net: P4
      key.stagger: inner_stagger
      rows.bottom.skip: true # again, 23332 cluster
  center:
    anchor:
      - ref: matrix_middle_bottom
        shift: [0, -0.5ky] # this compensation should be part of center_y... why two shifts, come on man
      - shift: [center_x, center_y]
        rotate: -center_r # this is bad! it should be oriented, *then* shifted by [center_x, center_y]. 
        # but this has already been put into production. Oh well.
    key.width: square  # board outline
    key.height: square
  encoder: &matrix # potentially invert nets for pretty diode
    key.$extends: points.zones.matrix.key
    key.row_net: P4
    key.col_net: P1
    key.name: matrix_{{zone.name}} 
    key.tags: [encoder, switches]
    anchor.ref: matrix_middle_bottom
    anchor.shift: [0, -ky]
  thumb: # potentially invert nets for pretty diode
    <<: *matrix
    key.spread: -kx
    key.name: matrix_{{zone.name}}_{{col.name}}
    key.col_net: P2
    key.tags: [switches]
    anchor.ref: center
    anchor.shift: [square/2-kx/2+thumb_x, -square/2+ky/2+thumb_y]
    columns:
      thumb.key:
        splay: center_r -thumb_r
        adjust.rotate: -90
    #  enc.key.tags: [encoder]
  corner: # potentially invert nets for pretty diode
    <<: *matrix 
    key.col_net: P0
    key.rotate: 180-corner_r
    key.tags: [switches]
    anchor.ref: center
    anchor.shift: [-square/2+kx/2+corner_x, -square/2+ky/2+corner_y]

# === COMPONENTS PREFACE: ===
# all components have widths and heights. This is only for demo.dxf. They serve no technical purpose.
# The anchors get a little messy; reading documentation WILL help here.
# Most anchors are at a corner or edge of the component. There is then an adjustment finalize the placement, this is only for clarity's sake.
  xiao: # mcu
    key.width: xiao_x
    key.height: xiao_y
    anchor:
      aggregate:
        method: intersect
        parts:
          - ref: matrix_ring_bottom
            shift: [0, -ky/2 - xiao_x - 3] # 3 is the gap between xiao and bottom of ring col
            rotate: 90
          - ref: center
            shift: [-square/2-0.8, 0] # 0.8 brings the xiao closer to the edge (a little beyond it, really)
    key.splay: center_r+ring_splay # intersect only yields [x, y], we have to give it back its rotation
    key.adjust:
      orient: 90 # make it face outside
      shift: [xiao_x/2, -xiao_y/2]
  trrs: # for wired split
    key.width: trrs_x
    key.height: trrs_y 
    anchor:
      aggregate:
        method: intersect
        parts:
          - ref: matrix_inner_top
            shift: [14/2 + 2 + trrs_x, 0] # 14 is half the width of a key's plate cutout. 2 is the value between trrs and key.
          - ref: center
            shift: [square/2, 0] 
    key.adjust:
      orient: center_r  # make it parallel to inner col
      shift: [-trrs_x/2+0.5, -trrs_y/2] # 0.5 is because the actual pin holes are a bit further in than the edge
  slider: # power switch
    key.width: slider_x
    key.height: slider_y
    anchor:
      - ref: matrix_inner_top
        shift: [-kx/2+slider_x/2+2, ky/2+(slider_y+1)/2]  # a lot of manual adjustment here,
        rotate: -26 # since it's based on the outline, which is an arc that's barely parametric at all. 
      - shift: [-1.5, 2.8] # Ugly, I hate it, but hey. Had to get this board done.
    key.adjust:
      shift: [0, -slider_y/2]
  reset: # reset switch
    key.width: reset_x
    key.height: reset_y
    anchor:
      aggregate:
        method: intersect # Similar method to how trrs was placed.
        parts:
          - ref: trrs
            shift: [0, -trrs_y/2-1.5]
            rotate: 90
          - ref: center
            shift: [square/2, 0] 
    key.adjust:
      orient: center_r
      shift: [-reset_x/2-1, -reset_y/2]
  cr2032: # coin cell battery. "Coin" name is only used for measurements, since numbers are a *little* more annoying to type.
    key.width: coin_x
    key.height: coin_y
    anchor:
      - ref: center
        shift: [0, -square/2]
      - ref: matrix_corner
        affect: x
      - shift: [kx/2 + 11, 2.425] # manual adjustments. Stinky!!
    key.adjust:
      shift: [coin_x/2, coin_y/2]
  jst: # battery connector
    key.width: jst_x
    key.height: jst_y
    anchor: 
      - ref: center
        shift: [0, -square/2 + 1.5]
      - ref: cr2032
        shift: [coin_x/2 + 4, 0]
        affect: x
    key.adjust:
      orient: 90
      shift: [jst_x/2, -jst_y/2]
  slider2: # battery swapping switch
    key.width: slider_x2
    key.height: slider_y2
    anchor:
      - ref: jst
        affect: [x, y]
      - shift: [-jst_y/2, jst_x/2 + 1]
    key.adjust:
      shift: [slider_x2/2, slider_y2/2]
outlines:
  # =============== components =============
  _xiao:
    - what: rectangle   # base xiao
      where: xiao
      size: [xiao_x, xiao_y]
      corner: 1.5
  _xiao_head:
    - what: rectangle   # in front of xiao
      size: [xiao_x, xiao_y+8]
      where: 
        - ref: xiao
          shift: [0, (sy-xiao_y)/2]
      corner: 1.5
      expand: 1
  _reset:
    - what: rectangle
      where: reset
      size: [reset_x, reset_y]
  _slider:
    - what: rectangle
      where: slider
      adjust.shift: [0, -0.5] # compensation for center of zone vs center of footprint
      size: [slider_x, slider_y+1]
  _slider2:
    - what: rectangle
      where: slider2
      size: [slider_x2, slider_y2]
  _jst:
    - what: rectangle
      where: jst
      size: [jst_x, jst_y]
  _cr2032:
    - what: path # this path could be done using the intersect of a rectangle and a circle. ...I forgot about that when making this.
      segments:
        - type: arc # left edge
          points: 
            - ref: cr2032
              shift: [-7.9183-1.8, -coin_y/2]
            - ref: cr2032
              shift: [-11.15-1.8, 0]
            - ref: cr2032
              shift: [-7.9183-1.8, coin_y/2]
        - type: line # line connecting it to the right "edge"
          points:
            - ref: cr2032
              shift: [7.9183-1.8, coin_y/2]
        - type: arc # right "edge"; below is a rectangle, the true right edge
          points: 
            - ref: cr2032
              shift: [11.15-1.8, 0]
            - ref: cr2032
              shift: [7.9183-1.8, -coin_y/2]
    - what: rectangle # the true right edge!
      where: cr2032
      adjust.shift: [sx/2-1.8, 0]
      size: [12.95, 13]
    - what: circle # the battery's outline
      where: cr2032
      adjust.shift: [-1.8, 0] # compensation for center of zone vs center of footprint
      radius: 10
  _cr2032_head: # additional head space for coin, slider2, and jst (for the plate)
    - name: _cr2032
    - what: rectangle
      where: cr2032
      size: [24.1, coin_y]
      adjust.shift: [-(coin_x-24.1)/2, -coin_y/2] # below coin
    - what: rectangle
      where: 
        - slider2
        - ref: jst
          affect: x
        - shift: [jst_y/2-sx/2-2, slider_y2/2-sy/2] # over all comps
      size: [25, 30]
    #- name: _jst
    #- name: _slider2
      expand: 2> # find what this means in the documentation :)
  _trrs:
    - what: rectangle
      where: trrs
      size: [trrs_x, trrs_y]
  _trrs_head: # additional head space for trrs, reset
    - what: polygon
      points: 
        - aggregate:
            method: intersect
            parts:
              - ref: trrs
                shift: [-trrs_x/2, 0]
              - ref: reset
                shift: [0, -reset_y/2]
                rotate: 90
          rotate: center_r
        - shift: [0, 50] # arbitrary values, just to fill out the shape
        - shift: [15, 0]
        - shift: [0, -50]
      expand: 0.5
  # ================= core =================
  _key_footprint: # helper outline to visualise the space each key occupies on the pcb
    - what: polygon
      where: /matrix/
      points:
        - ref: zero
          shift: [2.54+gap, m_y] # m ring
        - ref: zero
          shift: [7.365+gap, m_xy] # m t pad t
        - ref: zero
          shift: [m_x, 3.79+gap] # m b pad t 
        - ref: zero
          shift: [m_x, 1.29+gap] # m b pad b
        - ref: zero
          shift: [c_x, -2.45-gap] # c t pad t
        - ref: zero
          shift: [c_x, -c_xy] # c t pad b
        - ref: zero
          shift: [4.57+gap, -7.25-gap] # c b pad b
        - ref: zero
          shift: [0, -c_y] # c ring
        - ref: zero
          shift: [-4.57-gap, -7.25-gap] # c b pad b
        - ref: zero
          shift: [-c_x, -c_xy] # c t pad b
        - ref: zero
          shift: [-c_x, -2.45-gap] # c t pad t
        - ref: zero
          shift: [-m_x, 1.29+gap] # m b pad b
        - ref: zero
          shift: [-m_x, 3.79+gap] # m b pad t 
        - ref: zero
          shift: [-7.365-gap, m_xy] # m t pad t
        - ref: zero
          shift: [-2.54-gap, m_y] # m ring
  _keycaps:
    - what: rectangle
      where: [switches] # here it is! a tag
      size: [kcx, kcy]
    - what: circle
      where: encoder
      radius: 14.4/2 # measured from the knobs I have onhand
      operation: stack
  _key_cutouts:
    - what: rectangle
      where: /matrix|encoder/
      size: 14
      corner: 0.5 # so they don't get filleted again down the line
  _limits:
    - what: rectangle
      where: center
      size: [square-0.15, square-0.15] # -0.15 is because for SOME UNKNOWN REASON,
      # the plate comes out sliiightly oversized when uploaded to jlc. >:((
  _main_outline:
    - what: path
      segments: 
        - type: line # [edge, -edge] to  [-edge, corner]
          points: 
            - ref: matrix_thumb_thumb
              shift: [-kx/2, ky/2] 
            - ref: matrix_thumb_thumb
              shift: [kx/2, ky/2]
            - ref: center # bot left corner
              shift: [-square/2, -square/2]
            - ref: matrix_corner # corner's top
              shift: [kx/2, 0]
              affect: y
            - aggregate: # pinky col's left edge, intersected with center
                method: intersect
                parts:
                  - ref: center
                    shift: [-square/2, 0]
                  - ref: matrix_pinky_top
                    shift: [-c_x, 0]
            - ref: matrix_pinky_top # pinky col's top left corner
              shift: [-c_x, m_xy]
        - type: arc # big edge from pinky, trough middle's tip, to inner's top right corner
          points:
            - ref: matrix_middle_top
              shift: [0, 7+1.75]
            - ref:
              - ref: center
                shift: [square/2, 0]
              - ref: matrix_inner_top
                shift: [kx/2, ky/2 -3]
                affect: y
  _pcb_out: # constrain the outline to 102x102
    - _main_outline
    - ~_limits
  # ================= outlines ===============            
  preview: # helper, broad overview of the pcb.
    # Mostly exists because demo.dxf makes the "zero" zone visible, offsetting the display a lot.
    - _keycaps
    - ^_pcb_out
  footprint_outlines: # helper, to visualise evrything on the pcb simultaneously. Certainly what I looked at the most.
    - _main_outline
    - ^_limits
    - ^_key_footprint
    - ^_xiao_head
    - ^_trrs
    - ^_reset
    - ^_cr2032
    - ^_slider
    - ^_slider2
    - ^_jst
  pcb_o: # filleted pcb outline
    - name: _pcb_out
      fillet: 1 
  _plate_out: # the plate, minus cutouts, and filleted
    - pcb_o
    - name: _trrs_head
      operation: subtract
      fillet: 0.5
    - name: _xiao_head # needs a smaller fillet, 1-2, to trigger immediately
      operation: subtract
      fillet: 1.5
    - name: _cr2032_head
      operation: subtract
      fillet: 1.5
  plate_o: 
    - name: _plate_out
    - name: _key_cutouts
      operation: subtract

pcbs:
  ravine:
    template: kicad8
    outlines.main.outline: pcb_o
    footprints:
      switches:
        what: sw_combo
        where: switches
        params:
          from: "{{colrow}}" # > switch
          to: "{{row_net}}" # > diode
      encoder: 
        what: ceoloide/rotary_encoder_ec11_ec12
        where: [encoder]
        params:
          reversible: true
          include_plated_mounting_holes: false
          mounting_holes_position: 8
          encoder_pads_position: 8.35
          S1: net_name
          S2: "{{row_net}}"
          A: enc1
          C: enc2
      diode_array:
        what: diode_rev
        where: /diode/
        params:
          from: "{{row_net}}"
          to: "{{col_net}}"
        adjust.rotate: 90
      diode: &diode #adjust diode rotations correctly
        what: diode_rev
        where: [[/matrix_(?!pinky)/, -encoder]]
        params:
          from: "{{colrow}}" # > diode
          to: "{{col_net}}" # > mcu
        adjust.shift: [-5, -8.35]
      diode1:
        <<: *diode
        where: /matrix_pinky_top/
        adjust.shift: [5, -8.35]
        adjust.rotate: 180
      diode2:
        <<: *diode
        where: /matrix_pinky_home/
        adjust.shift: [-4.5, 8.35]
      diode3:
        <<: *diode
        where: [encoder] # encoders
        adjust.shift: [-6.8, -8.35]
        params.from: net_name
      xiao:
        what: xiao
        where: xiao
        params:
          # nfc1, nfc2 are free
          P5: trrs
          P9: enc1
          P10: enc2
          # P4 & P5 are high-frequency
          # right side = p7-p10
      reset: &reset
        what: ceoloide/reset_switch_tht_top
        where: reset
        params:
          from: GND
          to: RST
      reset2: # optional tht or smd button
        <<: *reset
        what: button
      slider:
        what: ceoloide/power_switch_smd_side
        where: slider
        adjust.rotate: 90
        params:
          from: battery
          to: BAT_POS
          reversible: true
      slider2:
        what: mss_rev
        where: slider2
        params:
          L: coin_bat
          M: battery
          R: jst_bat 
      trrs:
        what: ceoloide/trrs_pj320a
        where: trrs
        adjust.shift: [0, trrs_y/2]
        params:
          reversible: true
          symmetric: true
          TP: VCC
          R2: trrs
          SL: GND
      jst:
        what: ceoloide/battery_connector_jst_ph_2
        where: jst
        adjust.shift: [0, 4.35]
        params:
          reversible: true
          BAT_P: jst_bat
          BAT_N: GND
      cr2032: # bs-2032-8 component
        what: cr2032
        where: cr2032
        adjust.shift: [-1.8, 0]
        params:
          BAT_P: coin_bat
          GND: GND
  ravine_plate:
    template: kicad8
    outlines.main.outline: plate_o